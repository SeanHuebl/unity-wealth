// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: transactions.sql

package database

import (
	"context"
	"database/sql"
)

const createTransaction = `-- name: CreateTransaction :exec
INSERT INTO transactions (
        id,
        user_id,
        transaction_date,
        merchant,
        amount_cents,
        detailed_category_id
    )
VALUES (?1, ?2, ?3, ?4, ?5, ?6)
`

type CreateTransactionParams struct {
	ID                 string
	UserID             string
	TransactionDate    string
	Merchant           string
	AmountCents        int64
	DetailedCategoryID int64
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) error {
	_, err := q.db.ExecContext(ctx, createTransaction,
		arg.ID,
		arg.UserID,
		arg.TransactionDate,
		arg.Merchant,
		arg.AmountCents,
		arg.DetailedCategoryID,
	)
	return err
}

const deleteTransactionByID = `-- name: DeleteTransactionByID :exec
DELETE FROM transactions
WHERE id = ?1
    AND user_id = ?2
`

type DeleteTransactionByIDParams struct {
	ID     string
	UserID string
}

func (q *Queries) DeleteTransactionByID(ctx context.Context, arg DeleteTransactionByIDParams) error {
	_, err := q.db.ExecContext(ctx, deleteTransactionByID, arg.ID, arg.UserID)
	return err
}

const getDetailedCategories = `-- name: GetDetailedCategories :many
SELECT id, name, description, primary_category_id
FROM detailed_categories
`

func (q *Queries) GetDetailedCategories(ctx context.Context) ([]DetailedCategory, error) {
	rows, err := q.db.QueryContext(ctx, getDetailedCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DetailedCategory
	for rows.Next() {
		var i DetailedCategory
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Description,
			&i.PrimaryCategoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDetailedCategoryID = `-- name: GetDetailedCategoryID :one
SELECT id
FROM detailed_categories
WHERE name = ?1
`

func (q *Queries) GetDetailedCategoryID(ctx context.Context, name string) (int64, error) {
	row := q.db.QueryRowContext(ctx, getDetailedCategoryID, name)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const getPrimaryCategories = `-- name: GetPrimaryCategories :many
SELECT id, name
FROM primary_categories
`

func (q *Queries) GetPrimaryCategories(ctx context.Context) ([]PrimaryCategory, error) {
	rows, err := q.db.QueryContext(ctx, getPrimaryCategories)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []PrimaryCategory
	for rows.Next() {
		var i PrimaryCategory
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserTransactionByID = `-- name: GetUserTransactionByID :one
SELECT id,
    user_id,
    transaction_date,
    merchant,
    amount_cents,
    detailed_category_id
FROM transactions
WHERE user_id = ?1
    AND id = ?2
LIMIT 1
`

type GetUserTransactionByIDParams struct {
	UserID string
	ID     string
}

type GetUserTransactionByIDRow struct {
	ID                 string
	UserID             string
	TransactionDate    string
	Merchant           string
	AmountCents        int64
	DetailedCategoryID int64
}

func (q *Queries) GetUserTransactionByID(ctx context.Context, arg GetUserTransactionByIDParams) (GetUserTransactionByIDRow, error) {
	row := q.db.QueryRowContext(ctx, getUserTransactionByID, arg.UserID, arg.ID)
	var i GetUserTransactionByIDRow
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.TransactionDate,
		&i.Merchant,
		&i.AmountCents,
		&i.DetailedCategoryID,
	)
	return i, err
}

const getUserTransactionsFirstPage = `-- name: GetUserTransactionsFirstPage :many
SELECT id,
    user_id,
    transaction_date,
    merchant,
    amount_cents,
    detailed_category_id
FROM transactions
WHERE user_id = ?1
ORDER BY transaction_date DESC,
    id ASC
LIMIT ?2
`

type GetUserTransactionsFirstPageParams struct {
	UserID string
	Limit  int64
}

type GetUserTransactionsFirstPageRow struct {
	ID                 string
	UserID             string
	TransactionDate    string
	Merchant           string
	AmountCents        int64
	DetailedCategoryID int64
}

func (q *Queries) GetUserTransactionsFirstPage(ctx context.Context, arg GetUserTransactionsFirstPageParams) ([]GetUserTransactionsFirstPageRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserTransactionsFirstPage, arg.UserID, arg.Limit)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserTransactionsFirstPageRow
	for rows.Next() {
		var i GetUserTransactionsFirstPageRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TransactionDate,
			&i.Merchant,
			&i.AmountCents,
			&i.DetailedCategoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getUserTransactionsPaginated = `-- name: GetUserTransactionsPaginated :many
SELECT id,
    user_id,
    transaction_date,
    merchant,
    amount_cents,
    detailed_category_id
FROM transactions
WHERE user_id = ?1
    AND (
        transaction_date < ?2
        OR (
            transaction_date = ?2
            AND id < ?3
        )
    )
ORDER BY transaction_date DESC,
    id ASC
LIMIT ?4
`

type GetUserTransactionsPaginatedParams struct {
	UserID          string
	TransactionDate string
	ID              string
	Limit           int64
}

type GetUserTransactionsPaginatedRow struct {
	ID                 string
	UserID             string
	TransactionDate    string
	Merchant           string
	AmountCents        int64
	DetailedCategoryID int64
}

func (q *Queries) GetUserTransactionsPaginated(ctx context.Context, arg GetUserTransactionsPaginatedParams) ([]GetUserTransactionsPaginatedRow, error) {
	rows, err := q.db.QueryContext(ctx, getUserTransactionsPaginated,
		arg.UserID,
		arg.TransactionDate,
		arg.ID,
		arg.Limit,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetUserTransactionsPaginatedRow
	for rows.Next() {
		var i GetUserTransactionsPaginatedRow
		if err := rows.Scan(
			&i.ID,
			&i.UserID,
			&i.TransactionDate,
			&i.Merchant,
			&i.AmountCents,
			&i.DetailedCategoryID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTransactionByID = `-- name: UpdateTransactionByID :one
UPDATE transactions
SET transaction_date = ?1,
    merchant = ?2,
    amount_cents = ?3,
    detailed_category_id = ?4,
    updated_at = ?5
WHERE id = ?6
RETURNING id,
    transaction_date,
    merchant,
    amount_cents,
    detailed_category_id
`

type UpdateTransactionByIDParams struct {
	TransactionDate    string
	Merchant           string
	AmountCents        int64
	DetailedCategoryID int64
	UpdatedAt          sql.NullTime
	ID                 string
}

type UpdateTransactionByIDRow struct {
	ID                 string
	TransactionDate    string
	Merchant           string
	AmountCents        int64
	DetailedCategoryID int64
}

func (q *Queries) UpdateTransactionByID(ctx context.Context, arg UpdateTransactionByIDParams) (UpdateTransactionByIDRow, error) {
	row := q.db.QueryRowContext(ctx, updateTransactionByID,
		arg.TransactionDate,
		arg.Merchant,
		arg.AmountCents,
		arg.DetailedCategoryID,
		arg.UpdatedAt,
		arg.ID,
	)
	var i UpdateTransactionByIDRow
	err := row.Scan(
		&i.ID,
		&i.TransactionDate,
		&i.Merchant,
		&i.AmountCents,
		&i.DetailedCategoryID,
	)
	return i, err
}
